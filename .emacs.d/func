;;; expand-function.el --- Quickly expand words to function definitions

;; Copyright (C) 2023 mrsilver

;; Author: Your Name <mrssilver1209@icloud.com>>
;; URL: https://github.com/mrssivler/expand-function
;; Version: 1.0.0
;; Package-Requires: ((emacs "27.1") (evil "1.0"))
;; Keywords: productivity, programming, functions

;;; Commentary:
;; This plugin allows you to quickly expand words under cursor to complete
;; function definitions in various programming languages with proper syntax.

;;; Usage:
;; (require 'expand-function)
;; (expand-function-setup)

;; Then in any programming mode:
;;   - Position cursor on a word and press "fw" to expand it to a function
;;   - Use prefix arguments (C-2 fw) to expand multiple words
;;   - Or visually select words and press "fw" to expand all selected

;;; Code:

(require 'evil)

(defgroup expand-function nil
  "Quickly expand words to function definitions."
  :group 'programming
  :prefix "expand-function-")

(defcustom expand-function-key "fw"
  "Key sequence to bind for expand function command."
  :type 'string
  :group 'expand-function)

(defcustom expand-function-python-indent 4
  "Python function body indentation level."
  :type 'integer
  :group 'expand-function)

(defcustom expand-function-other-indent 4
  "Default function body indentation level for other languages."
  :type 'integer
  :group 'expand-function)

(defcustom expand-function-go-param-style "()"
  "Parameter style for Go functions."
  :type 'string
  :group 'expand-function
  :options '("()" "(arg string)"))

(defcustom expand-function-c-param-style "void"
  "Parameter style for C functions."
  :type 'string
  :group 'expand-function
  :options '("void" "int argc, char *argv[]"))

(defvar expand-function--templates
  `((c-mode . ,(lambda (word indent)
                 (format "%s%s %s(%s)\n%s{\n%s%s\n%s}\n\n"
                         indent (if (derived-mode-p 'c++-mode) "" "void")
                         word expand-function-c-param-style
                         indent indent (make-string expand-function-other-indent ? ) indent)))
    (zig-mode . ,(lambda (word indent)
                   (format "%sfn %s() void {\n%s%s\n%s}\n\n"
                           indent word indent 
                           (make-string expand-function-other-indent ? ) indent)))
    (go-mode . ,(lambda (word indent)
                  (format "%sfunc %s%s {\n%s%s\n%s}\n\n"
                          indent word expand-function-go-param-style
                          indent (make-string expand-function-other-indent ? ) indent)))
    (python-mode . ,(lambda (word indent)
                      (format "%sdef %s():\n%s%s\n"
                              indent word indent 
                              (make-string expand-function-python-indent ? ))))
    (default . ,(lambda (word indent)
                  (format "%sfunction %s() {\n%s%s\n%s}\n\n"
                          indent word indent 
                          (make-string expand-function-other-indent ? ) indent))))
  "Templates for various programming languages.")

;;;###autoload
(defun expand-function-expand-n-words (n)
  "Expand the next N words into separate function definitions."
  (interactive "p")
  (let* ((indent (make-string (current-indentation) ? ))
         (start (point))
         words
         bounds
         (mode (cond ((derived-mode-p 'c-mode 'c++-mode 'c-or-c++-mode) 'c-mode)
                     ((derived-mode-p 'zig-mode) 'zig-mode)
                     ((derived-mode-p 'go-mode) 'go-mode)
                     ((derived-mode-p 'python-mode) 'python-mode)
                     (t 'default))))
    
    ;; Collect N words
    (dotimes (i n)
      (when (re-search-forward "\\_<\\w+\\_>" nil t)
        (push (match-string 0) words)
        (setq bounds (or bounds (cons start (point)))))
      (forward-word 1))
    
    (if (null words)
        (user-error "No words found at point")
      
      ;; Delete original words
      (delete-region (car bounds) (cdr bounds))
      (setq words (nreverse words))
      
      ;; Insert function definitions
      (let ((template-fn (cdr (assoc mode expand-function--templates)))
            (first t))
        (dolist (word words)
          (insert (funcall template-fn word indent))
          (when first
            (backward-char)  ; Position for editing
            (search-backward "{")
            (unless (derived-mode-p 'python-mode) 
              (forward-char 1))
            (setq first nil)))
        (search-backward "{")
        (if (derived-mode-p 'python-mode)
            (forward-line 1)
          (forward-char 1))
        (indent-according-to-mode)
        (evil-insert-state)))))

;;;###autoload
(defun expand-function-expand-region ()
  "Expand selected words in visual mode to function definitions."
  (interactive)
  (if (not (evil-visual-state-p))
      (user-error "Not in visual mode")
    (let ((n (count-words-region (region-beginning) (region-end))))
      (evil-normal-state)
      (expand-function-expand-n-words n))))

;;;###autoload
(defun expand-function-setup ()
  "Set up keybindings for expand-function."
  (interactive)
  
  (dolist (hook '(prog-mode-hook
                  c-mode-common-hook
                  zig-mode-hook
                  go-mode-hook
                  python-mode-hook
                  js-mode-hook
                  typescript-mode-hook
                  ruby-mode-hook
                  rust-mode-hook
                  php-mode-hook
                  lua-mode-hook
                  java-mode-hook
                  emacs-lisp-mode-hook
                  clojure-mode-hook
                  scheme-mode-hook))
    (add-hook hook #'expand-function-mode))
  
  (expand-function-mode 1))

(define-minor-mode expand-function-mode
  "Minor mode for expanding words to function definitions."
  :keymap `((,(kbd expand-function-key) . expand-function-expand-n-words))
  :group 'expand-function
  :global nil
  (if expand-function-mode
      (progn
        (add-hook 'evil-visual-state-entry-hook 
                  (lambda ()
                    (local-set-key (kbd expand-function-key) 
                                   #'expand-function-expand-region)) nil t)
        (message "expand-function mode enabled"))
    (progn
      (remove-hook 'evil-visual-state-entry-hook 
                   (lambda ()
                     (local-set-key (kbd expand-function-key) 
                                    #'expand-function-expand-region)) t)
      (message "expand-function mode disabled"))))

(provide 'expand-function)
;;; expand-function.el ends here


安装方法

1. 手动安装:

  ◦ 将上述代码保存为 expand-function.el

  ◦ 添加到加载路径并添加至启动文件:

(add-to-list 'load-path "/path/to/plugin")
(require 'expand-function)
(expand-function-setup)


基本用法

1. 单个函数扩展:

  ◦ 将光标放在单词上

  ◦ 按下 fw

  ◦ 插件会自动生成完整的函数定义

2. 多个函数扩展:

  ◦ 使用数字前缀指定单词数量，例如：

C-3 fw


会扩展接下来的3个单词为3个函数定义

3. 可视模式扩展:

  ◦ 选择多个单词

  ◦ 按下 fw

  ◦ 所有选中的单词都会被扩展为函数定义

支持的语言

语言	生成格式	例子
C/C++	void func(void) {...}	C 风格函数
Go	func name() {...}	Go 函数
Python	def name(): ...	Python 函数
Zig	fn name() void {...}	Zig 函数
JavaScript	function name() {...}	JS 函数
TypeScript	function name() {...}	TS 函数
Rust	fn name() {...}	Rust 函数
Java	function name() {...}	默认
Ruby	function name() {...}	默认
PHP	function name() {...}	默认
Lua	function name() {...}	默认
Emacs Lisp	(defun name () ...)	Emacs Lisp 函数

自定义选项

1. 变量：expand-function-key (默认 "fw")

  ◦ 修改触发按键绑定

2. 变量：expand-function-python-indent (默认 4)

  ◦ Python 函数体的缩进空格数

3. 变量：expand-function-other-indent (默认 4)

  ◦ 其他语言函数体的缩进空格数

4. 变量：expand-function-go-param-style (默认 "()")

  ◦ Go 函数参数格式，可设为 "(arg string)" 等

5. 变量：expand-function-c-param-style (默认 "void")

  ◦ C 函数参数格式，可设为 "int argc, char *argv[]" 等


1. 智能语言检测：

  ◦ 自动识别当前语言模式

  ◦ 生成符合语言规范的函数定义

2. 精确的格式化：

  ◦ 保留当前缩进级别

  ◦ 函数体自动缩进

  ◦ 函数之间自动插入空行

3. 优化的用户体验：

  ◦ 光标自动定位在第一个函数体内

  ◦ 自动进入插入模式

  ◦ 上下文相关的参数风格

4. 灵活的扩展方式：

  ◦ 支持单个单词扩展

  ◦ 支持多单词扩展

  ◦ 支持视觉选择扩展

添加对新语言的支持

要添加对新语言的支持，只需扩展 expand-function--templates 变量：

(add-to-list 'expand-function--templates
             '(your-lang-mode . ,(lambda (word indent)
                 "Custom template")))









awk 'length > 80 {
    line = $0
    while (length(line) > 80) {
        # 检查第80-81字符是否是货币单位
        if (substr(line, 80, 2) ~ /^(美金|美元)$/) {
            print substr(line, 1, 79)
            line = substr(line, 80)
        } else {
            print substr(line, 1, 80)
            line = substr(line, 81)
        }
    }
    print line
    next
}1' input.txt






